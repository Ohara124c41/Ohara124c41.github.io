---
layout: post
title: "PID Controllers and Error Dynamics"
subtitle: "A Process Control Course Example"
author: "Christopher O’Hara"
header-style: text
tags:
  - PID
  - Control
  - Systems
  - Design
---

Proportional–Integral–Derivative (PID) controllers are the workhorse of process control and instrumentation. They appear everywhere: chemical reactors, power plants, spacecraft attitude loops, vehicle cruise control, robotics joint servos. The structure is simple yet powerful. But remember: **your system can only be as good as the measured data, so sensor quality is critical**. A noisy or drifting sensor immediately shows up in the controller output.

---

### PID

**Error Plot:**  
![Error Plot](https://github.com/Ohara124c41/Ohara124c41.github.io/blob/master/_posts/img/PID.jpg?raw=true)

The figure shows the error signal $e[k]$ sampled at $\Delta t = 1$ s for four steps.

We use the discrete “position form” PID law:

$$
u[k] = K_p e[k] + K_i \Delta t \sum_{i=0}^{k} e[i] + K_d \frac{e[k]-e[k-1]}{\Delta t}.
$$

Here $K_p, K_i, K_d$ are the proportional, integral, and derivative gains — weights applied to present, accumulated, and changing error.

For the given gains $K_p = 2, K_i = 0.5, K_d = 1$, compute the control output $u[3]$ using the error values read from the figure.

---

## Worked Example

**Problem statement:**  
From the plot, extract $e[0] = 0.0, e[1] = 1.0, e[2] = 0.5, e[3] = 0.2$.  
Evaluate $u[3]$.

---

### Step-by-step solution

First, read the error values from the image:  
**Step 1 (read from image):** $e[0]=0.0,\; e[1]=1.0,\; e[2]=0.5,\; e[3]=0.2$.  

Next, complete the integral sum of errors:  
**Step 2 (integral sum):** $\sum_{i=0}^{3} e[i] = 1.7.$  

Now, compute the proportional term:  
**Step 3 (proportional term):** $K_p e[3] = 2 \times 0.2 = 0.4.$  

Then, calculate the integral contribution:  
**Step 4 (integral term):** $K_i \Delta t \sum e = 0.5 \times 1.7 = 0.85.$  

Next, evaluate the derivative contribution:  
**Step 5 (derivative term):** $\tfrac{e[3]-e[2]}{\Delta t} = -0.3,$ so contribution is $-0.3.$  

Finally, sum all terms to get the PID output:  
**Step 6 (assemble PID output):** $u[3] = 0.4 + 0.85 - 0.3 = 0.95.$  

---

### Final Answer

`u[3] = 0.950`

---

### Why this matters

This compact calculation illustrates why PID remains so dominant in engineering practice:

1. **Domain breadth.**  
   PID is everywhere: it regulates steam temperature in boilers, controls pH in chemical mixing, damps oscillations in aircraft autopilots, holds altitude in drones, maintains speed in cars, and stabilizes cameras on robotic arms.

2. **Edge cases and limitations.**  
   A pure integral term leads to **windup**, where the controller output saturates if actuators are limited. Derivative action magnifies noise — if the sensor is jittery, $K_d$ makes it worse. Proportional alone cannot remove steady-state error in many processes.

3. **Expansions and practical fixes.**  
   Anti-windup strategies, filtered derivatives, gain scheduling, and adaptive PID variants are standard in modern practice. Instrumentation engineers often add feedforward paths or cascaded loops to overcome sensor delays and nonlinearities.

4. **Sensor dependence.**  
   A PID controller is only as good as the error it sees. Poor sensor calibration, time drift, or quantization noise can destabilize an otherwise stable loop. This is why aerospace and chemical industries invest heavily in robust measurement chains before tuning the controller.

---

Even this minimal four-sample problem exposes the essential tradeoffs in control: balancing responsiveness, accuracy, and stability while depending on sensors that are never perfect. That’s why PID remains not just a formula, but a design philosophy in process control.

---

### Exercise for readers

As an extension, try recomputing $u[3]$ with $K_d = 5$ instead of $1$. What happens to the derivative term and the final output? How does this illustrate the danger of derivative noise amplification in real systems?
